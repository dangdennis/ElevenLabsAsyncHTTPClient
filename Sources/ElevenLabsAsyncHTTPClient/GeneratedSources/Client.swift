// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// This is the documentation for the ElevenLabs API. You can use this API to use our service programmatically, this is done by using your xi-api-key. <br/> You can view your xi-api-key using the 'Profile' tab on https://elevenlabs.io. Our API is experimental so all endpoints are subject to change.
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Get Generated Items
    ///
    /// Returns metadata about all your generated audio.
    ///
    /// - Remark: HTTP `GET /v1/history`.
    /// - Remark: Generated from `#/paths//v1/history/get(Get_generated_items_v1_history_get)`.
    public func Get_generated_items_v1_history_get(_ input: Operations.Get_generated_items_v1_history_get.Input) async throws -> Operations.Get_generated_items_v1_history_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_generated_items_v1_history_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/history",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_size",
                    value: input.query.page_size
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start_after_history_item_id",
                    value: input.query.start_after_history_item_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "voice_id",
                    value: input.query.voice_id
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_generated_items_v1_history_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetSpeechHistoryResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_generated_items_v1_history_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get History Item By Id
    ///
    /// Returns information about an history item by its ID.
    ///
    /// - Remark: HTTP `GET /v1/history/{history_item_id}`.
    /// - Remark: Generated from `#/paths//v1/history/{history_item_id}/get(Get_history_item_by_ID_v1_history__history_item_id__get)`.
    public func Get_history_item_by_ID_v1_history__history_item_id__get(_ input: Operations.Get_history_item_by_ID_v1_history__history_item_id__get.Input) async throws -> Operations.Get_history_item_by_ID_v1_history__history_item_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_history_item_by_ID_v1_history__history_item_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/history/{}",
                    parameters: [
                        input.path.history_item_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_history_item_by_ID_v1_history__history_item_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SpeechHistoryItemResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_history_item_by_ID_v1_history__history_item_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete History Item
    ///
    /// Delete a history item by its ID
    ///
    /// - Remark: HTTP `DELETE /v1/history/{history_item_id}`.
    /// - Remark: Generated from `#/paths//v1/history/{history_item_id}/delete(Delete_history_item_v1_history__history_item_id__delete)`.
    public func Delete_history_item_v1_history__history_item_id__delete(_ input: Operations.Delete_history_item_v1_history__history_item_id__delete.Input) async throws -> Operations.Delete_history_item_v1_history__history_item_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_history_item_v1_history__history_item_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/history/{}",
                    parameters: [
                        input.path.history_item_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_history_item_v1_history__history_item_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_history_item_v1_history__history_item_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Audio From History Item
    ///
    /// Returns the audio of an history item.
    ///
    /// - Remark: HTTP `GET /v1/history/{history_item_id}/audio`.
    /// - Remark: Generated from `#/paths//v1/history/{history_item_id}/audio/get(Get_audio_from_history_item_v1_history__history_item_id__audio_get)`.
    public func Get_audio_from_history_item_v1_history__history_item_id__audio_get(_ input: Operations.Get_audio_from_history_item_v1_history__history_item_id__audio_get.Input) async throws -> Operations.Get_audio_from_history_item_v1_history__history_item_id__audio_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_audio_from_history_item_v1_history__history_item_id__audio_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/history/{}/audio",
                    parameters: [
                        input.path.history_item_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_audio_from_history_item_v1_history__history_item_id__audio_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "audio/mpeg"
                        ]
                    )
                    switch chosenContentType {
                    case "audio/mpeg":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .audio_mpeg(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_audio_from_history_item_v1_history__history_item_id__audio_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Download History Items
    ///
    /// Download one or more history items. If one history item ID is provided, we will return a single audio file. If more than one history item IDs are provided, we will provide the history items packed into a .zip file.
    ///
    /// - Remark: HTTP `POST /v1/history/download`.
    /// - Remark: Generated from `#/paths//v1/history/download/post(Download_history_items_v1_history_download_post)`.
    public func Download_history_items_v1_history_download_post(_ input: Operations.Download_history_items_v1_history_download_post.Input) async throws -> Operations.Download_history_items_v1_history_download_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Download_history_items_v1_history_download_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/history/download",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Download_history_items_v1_history_download_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Sample
    ///
    /// Removes a sample by its ID.
    ///
    /// - Remark: HTTP `DELETE /v1/voices/{voice_id}/samples/{sample_id}`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/samples/{sample_id}/delete(Delete_sample_v1_voices__voice_id__samples__sample_id__delete)`.
    public func Delete_sample_v1_voices__voice_id__samples__sample_id__delete(_ input: Operations.Delete_sample_v1_voices__voice_id__samples__sample_id__delete.Input) async throws -> Operations.Delete_sample_v1_voices__voice_id__samples__sample_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_sample_v1_voices__voice_id__samples__sample_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}/samples/{}",
                    parameters: [
                        input.path.voice_id,
                        input.path.sample_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_sample_v1_voices__voice_id__samples__sample_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_sample_v1_voices__voice_id__samples__sample_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Audio From Sample
    ///
    /// Returns the audio corresponding to a sample attached to a voice.
    ///
    /// - Remark: HTTP `GET /v1/voices/{voice_id}/samples/{sample_id}/audio`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/samples/{sample_id}/audio/get(Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get)`.
    public func Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get(_ input: Operations.Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get.Input) async throws -> Operations.Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}/samples/{}/audio",
                    parameters: [
                        input.path.voice_id,
                        input.path.sample_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "audio/*"
                        ]
                    )
                    switch chosenContentType {
                    case "audio/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .audio__ast_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Text To Speech
    ///
    /// Converts text into speech using a voice of your choice and returns audio.
    ///
    /// - Remark: HTTP `POST /v1/text-to-speech/{voice_id}`.
    /// - Remark: Generated from `#/paths//v1/text-to-speech/{voice_id}/post(Text_to_speech_v1_text_to_speech__voice_id__post)`.
    public func Text_to_speech_v1_text_to_speech__voice_id__post(_ input: Operations.Text_to_speech_v1_text_to_speech__voice_id__post.Input) async throws -> Operations.Text_to_speech_v1_text_to_speech__voice_id__post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Text_to_speech_v1_text_to_speech__voice_id__post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/text-to-speech/{}",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "optimize_streaming_latency",
                    value: input.query.optimize_streaming_latency
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "output_format",
                    value: input.query.output_format
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Text_to_speech_v1_text_to_speech__voice_id__post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "audio/mpeg"
                        ]
                    )
                    switch chosenContentType {
                    case "audio/mpeg":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .audio_mpeg(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Text_to_speech_v1_text_to_speech__voice_id__post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Text To Speech
    ///
    /// Converts text into speech using a voice of your choice and returns audio as an audio stream.
    ///
    /// - Remark: HTTP `POST /v1/text-to-speech/{voice_id}/stream`.
    /// - Remark: Generated from `#/paths//v1/text-to-speech/{voice_id}/stream/post(Text_to_speech_v1_text_to_speech__voice_id__stream_post)`.
    public func Text_to_speech_v1_text_to_speech__voice_id__stream_post(_ input: Operations.Text_to_speech_v1_text_to_speech__voice_id__stream_post.Input) async throws -> Operations.Text_to_speech_v1_text_to_speech__voice_id__stream_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Text_to_speech_v1_text_to_speech__voice_id__stream_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/text-to-speech/{}/stream",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "optimize_streaming_latency",
                    value: input.query.optimize_streaming_latency
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "output_format",
                    value: input.query.output_format
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Text_to_speech_v1_text_to_speech__voice_id__stream_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Speech To Speech
    ///
    /// Create speech by combining the content and emotion of the uploaded audio with a voice of your choice.
    ///
    /// - Remark: HTTP `POST /v1/speech-to-speech/{voice_id}`.
    /// - Remark: Generated from `#/paths//v1/speech-to-speech/{voice_id}/post(Speech_to_Speech_v1_speech_to_speech__voice_id__post)`.
    public func Speech_to_Speech_v1_speech_to_speech__voice_id__post(_ input: Operations.Speech_to_Speech_v1_speech_to_speech__voice_id__post.Input) async throws -> Operations.Speech_to_Speech_v1_speech_to_speech__voice_id__post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Speech_to_Speech_v1_speech_to_speech__voice_id__post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/speech-to-speech/{}",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "optimize_streaming_latency",
                    value: input.query.optimize_streaming_latency
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "audio"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "model_id",
                            "voice_settings"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .audio(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "audio",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .model_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "model_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .voice_settings(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "voice_settings",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Speech_v1_speech_to_speech__voice_id__post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "audio/mpeg"
                        ]
                    )
                    switch chosenContentType {
                    case "audio/mpeg":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .audio_mpeg(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Speech_v1_speech_to_speech__voice_id__post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Speech To Speech Streaming
    ///
    /// Create speech by combining the content and emotion of the uploaded audio with a voice of your choice and returns an audio stream.
    ///
    /// - Remark: HTTP `POST /v1/speech-to-speech/{voice_id}/stream`.
    /// - Remark: Generated from `#/paths//v1/speech-to-speech/{voice_id}/stream/post(Speech_to_Speech_Streaming_v1_speech_to_speech__voice_id__stream_post)`.
    public func Speech_to_Speech_Streaming_v1_speech_to_speech__voice_id__stream_post(_ input: Operations.Speech_to_Speech_Streaming_v1_speech_to_speech__voice_id__stream_post.Input) async throws -> Operations.Speech_to_Speech_Streaming_v1_speech_to_speech__voice_id__stream_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Speech_to_Speech_Streaming_v1_speech_to_speech__voice_id__stream_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/speech-to-speech/{}/stream",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "optimize_streaming_latency",
                    value: input.query.optimize_streaming_latency
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "audio"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "model_id",
                            "voice_settings"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .audio(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "audio",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .model_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "model_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .voice_settings(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "voice_settings",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Speech_Streaming_v1_speech_to_speech__voice_id__stream_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Voice Generation Parameters
    ///
    /// Get possible parameters for the /v1/voice-generation/generate-voice endpoint.
    ///
    /// - Remark: HTTP `GET /v1/voice-generation/generate-voice/parameters`.
    /// - Remark: Generated from `#/paths//v1/voice-generation/generate-voice/parameters/get(Voice_Generation_Parameters_v1_voice_generation_generate_voice_parameters_get)`.
    public func Voice_Generation_Parameters_v1_voice_generation_generate_voice_parameters_get(_ input: Operations.Voice_Generation_Parameters_v1_voice_generation_generate_voice_parameters_get.Input) async throws -> Operations.Voice_Generation_Parameters_v1_voice_generation_generate_voice_parameters_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Voice_Generation_Parameters_v1_voice_generation_generate_voice_parameters_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voice-generation/generate-voice/parameters",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Voice_Generation_Parameters_v1_voice_generation_generate_voice_parameters_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.VoiceGenerationParameterResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Generate A Random Voice
    ///
    /// Generate a random voice based on parameters. This method returns a generated_voice_id in the response header, and a sample of the voice in the body. If you like the generated voice call /v1/voice-generation/create-voice with the generated_voice_id to create the voice.
    ///
    /// - Remark: HTTP `POST /v1/voice-generation/generate-voice`.
    /// - Remark: Generated from `#/paths//v1/voice-generation/generate-voice/post(Generate_a_random_voice_v1_voice_generation_generate_voice_post)`.
    public func Generate_a_random_voice_v1_voice_generation_generate_voice_post(_ input: Operations.Generate_a_random_voice_v1_voice_generation_generate_voice_post.Input) async throws -> Operations.Generate_a_random_voice_v1_voice_generation_generate_voice_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Generate_a_random_voice_v1_voice_generation_generate_voice_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voice-generation/generate-voice",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Generate_a_random_voice_v1_voice_generation_generate_voice_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "audio/mpeg"
                        ]
                    )
                    switch chosenContentType {
                    case "audio/mpeg":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .audio_mpeg(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Generate_a_random_voice_v1_voice_generation_generate_voice_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create A Previously Generated Voice
    ///
    /// Create a previously generated voice. This endpoint should be called after you fetched a generated_voice_id using /v1/voice-generation/generate-voice.
    ///
    /// - Remark: HTTP `POST /v1/voice-generation/create-voice`.
    /// - Remark: Generated from `#/paths//v1/voice-generation/create-voice/post(Create_a_previously_generated_voice_v1_voice_generation_create_voice_post)`.
    public func Create_a_previously_generated_voice_v1_voice_generation_create_voice_post(_ input: Operations.Create_a_previously_generated_voice_v1_voice_generation_create_voice_post.Input) async throws -> Operations.Create_a_previously_generated_voice_v1_voice_generation_create_voice_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Create_a_previously_generated_voice_v1_voice_generation_create_voice_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voice-generation/create-voice",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_a_previously_generated_voice_v1_voice_generation_create_voice_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.VoiceResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_a_previously_generated_voice_v1_voice_generation_create_voice_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get User Subscription Info
    ///
    /// Gets extended information about the users subscription
    ///
    /// - Remark: HTTP `GET /v1/user/subscription`.
    /// - Remark: Generated from `#/paths//v1/user/subscription/get(Get_user_subscription_info_v1_user_subscription_get)`.
    public func Get_user_subscription_info_v1_user_subscription_get(_ input: Operations.Get_user_subscription_info_v1_user_subscription_get.Input) async throws -> Operations.Get_user_subscription_info_v1_user_subscription_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_user_subscription_info_v1_user_subscription_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/user/subscription",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_user_subscription_info_v1_user_subscription_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ExtendedSubscriptionResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_user_subscription_info_v1_user_subscription_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get User Info
    ///
    /// Gets information about the user
    ///
    /// - Remark: HTTP `GET /v1/user`.
    /// - Remark: Generated from `#/paths//v1/user/get(Get_user_info_v1_user_get)`.
    public func Get_user_info_v1_user_get(_ input: Operations.Get_user_info_v1_user_get.Input) async throws -> Operations.Get_user_info_v1_user_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_user_info_v1_user_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/user",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_user_info_v1_user_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_user_info_v1_user_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Voices
    ///
    /// Gets a list of all available voices for a user.
    ///
    /// - Remark: HTTP `GET /v1/voices`.
    /// - Remark: Generated from `#/paths//v1/voices/get(Get_voices_v1_voices_get)`.
    public func Get_voices_v1_voices_get(_ input: Operations.Get_voices_v1_voices_get.Input) async throws -> Operations.Get_voices_v1_voices_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_voices_v1_voices_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voices_v1_voices_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetVoicesResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voices_v1_voices_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Default Voice Settings.
    ///
    /// Gets the default settings for voices. "similarity_boost" corresponds to"Clarity + Similarity Enhancement" in the web app and "stability" corresponds to "Stability" slider in the web app.
    ///
    /// - Remark: HTTP `GET /v1/voices/settings/default`.
    /// - Remark: Generated from `#/paths//v1/voices/settings/default/get(Get_default_voice_settings__v1_voices_settings_default_get)`.
    public func Get_default_voice_settings__v1_voices_settings_default_get(_ input: Operations.Get_default_voice_settings__v1_voices_settings_default_get.Input) async throws -> Operations.Get_default_voice_settings__v1_voices_settings_default_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_default_voice_settings__v1_voices_settings_default_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/settings/default",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_default_voice_settings__v1_voices_settings_default_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.VoiceSettingsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Voice Settings
    ///
    /// Returns the settings for a specific voice. "similarity_boost" corresponds to"Clarity + Similarity Enhancement" in the web app and "stability" corresponds to "Stability" slider in the web app.
    ///
    /// - Remark: HTTP `GET /v1/voices/{voice_id}/settings`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/settings/get(Get_voice_settings_v1_voices__voice_id__settings_get)`.
    public func Get_voice_settings_v1_voices__voice_id__settings_get(_ input: Operations.Get_voice_settings_v1_voices__voice_id__settings_get.Input) async throws -> Operations.Get_voice_settings_v1_voices__voice_id__settings_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_voice_settings_v1_voices__voice_id__settings_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}/settings",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voice_settings_v1_voices__voice_id__settings_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.VoiceSettingsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voice_settings_v1_voices__voice_id__settings_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Voice
    ///
    /// Returns metadata about a specific voice.
    ///
    /// - Remark: HTTP `GET /v1/voices/{voice_id}`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/get(Get_voice_v1_voices__voice_id__get)`.
    public func Get_voice_v1_voices__voice_id__get(_ input: Operations.Get_voice_v1_voices__voice_id__get.Input) async throws -> Operations.Get_voice_v1_voices__voice_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_voice_v1_voices__voice_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "with_settings",
                    value: input.query.with_settings
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voice_v1_voices__voice_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.VoiceResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voice_v1_voices__voice_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Voice
    ///
    /// Deletes a voice by its ID.
    ///
    /// - Remark: HTTP `DELETE /v1/voices/{voice_id}`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/delete(Delete_voice_v1_voices__voice_id__delete)`.
    public func Delete_voice_v1_voices__voice_id__delete(_ input: Operations.Delete_voice_v1_voices__voice_id__delete.Input) async throws -> Operations.Delete_voice_v1_voices__voice_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_voice_v1_voices__voice_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_voice_v1_voices__voice_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_voice_v1_voices__voice_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Edit Voice Settings
    ///
    /// Edit your settings for a specific voice. "similarity_boost" corresponds to"Clarity + Similarity Enhancement" in the web app and "stability" corresponds to "Stability" slider in the web app.
    ///
    /// - Remark: HTTP `POST /v1/voices/{voice_id}/settings/edit`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/settings/edit/post(Edit_voice_settings_v1_voices__voice_id__settings_edit_post)`.
    public func Edit_voice_settings_v1_voices__voice_id__settings_edit_post(_ input: Operations.Edit_voice_settings_v1_voices__voice_id__settings_edit_post.Input) async throws -> Operations.Edit_voice_settings_v1_voices__voice_id__settings_edit_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Edit_voice_settings_v1_voices__voice_id__settings_edit_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}/settings/edit",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_voice_settings_v1_voices__voice_id__settings_edit_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_voice_settings_v1_voices__voice_id__settings_edit_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add Voice
    ///
    /// Add a new voice to your collection of voices in VoiceLab.
    ///
    /// - Remark: HTTP `POST /v1/voices/add`.
    /// - Remark: Generated from `#/paths//v1/voices/add/post(Add_voice_v1_voices_add_post)`.
    public func Add_voice_v1_voices_add_post(_ input: Operations.Add_voice_v1_voices_add_post.Input) async throws -> Operations.Add_voice_v1_voices_add_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_voice_v1_voices_add_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/add",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "name"
                        ],
                        requiredAtLeastOncePartNames: [
                            "files"
                        ],
                        atMostOncePartNames: [
                            "description",
                            "labels"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .name(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "name",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .files(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "files",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .description(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "description",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .labels(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "labels",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_voice_v1_voices_add_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddVoiceResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_voice_v1_voices_add_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Edit Voice
    ///
    /// Edit a voice created by you.
    ///
    /// - Remark: HTTP `POST /v1/voices/{voice_id}/edit`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/edit/post(Edit_voice_v1_voices__voice_id__edit_post)`.
    public func Edit_voice_v1_voices__voice_id__edit_post(_ input: Operations.Edit_voice_v1_voices__voice_id__edit_post.Input) async throws -> Operations.Edit_voice_v1_voices__voice_id__edit_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Edit_voice_v1_voices__voice_id__edit_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}/edit",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "name"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "description",
                            "labels"
                        ],
                        zeroOrMoreTimesPartNames: [
                            "files"
                        ],
                        encoding: { part in
                            switch part {
                            case let .name(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "name",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .files(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "files",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .description(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "description",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .labels(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "labels",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_voice_v1_voices__voice_id__edit_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_voice_v1_voices__voice_id__edit_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add Sharing Voice
    ///
    /// Add a sharing voice to your collection of voices in VoiceLab.
    ///
    /// - Remark: HTTP `POST /v1/voices/add/{public_user_id}/{voice_id}`.
    /// - Remark: Generated from `#/paths//v1/voices/add/{public_user_id}/{voice_id}/post(Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post)`.
    public func Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post(_ input: Operations.Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post.Input) async throws -> Operations.Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/add/{}/{}",
                    parameters: [
                        input.path.public_user_id,
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddVoiceResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Projects
    ///
    /// Returns a list of your projects together and its metadata.
    ///
    /// - Remark: HTTP `GET /v1/projects`.
    /// - Remark: Generated from `#/paths//v1/projects/get(Get_projects_v1_projects_get)`.
    public func Get_projects_v1_projects_get(_ input: Operations.Get_projects_v1_projects_get.Input) async throws -> Operations.Get_projects_v1_projects_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_projects_v1_projects_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_projects_v1_projects_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetProjectsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_projects_v1_projects_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add Project
    ///
    /// Creates a new project, it can be either initialized as blank, from a document or from a URL.
    ///
    /// - Remark: HTTP `POST /v1/projects/add`.
    /// - Remark: Generated from `#/paths//v1/projects/add/post(Add_project_v1_projects_add_post)`.
    public func Add_project_v1_projects_add_post(_ input: Operations.Add_project_v1_projects_add_post.Input) async throws -> Operations.Add_project_v1_projects_add_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_project_v1_projects_add_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/add",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "default_model_id",
                            "default_paragraph_voice_id",
                            "default_title_voice_id",
                            "name"
                        ],
                        requiredAtLeastOncePartNames: [
                            "pronunciation_dictionary_locators"
                        ],
                        atMostOncePartNames: [
                            "acx_volume_normalization",
                            "author",
                            "callback_url",
                            "from_document",
                            "from_url",
                            "isbn_number",
                            "quality_preset",
                            "title",
                            "volume_normalization"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .name(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "name",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .from_url(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "from_url",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .from_document(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "from_document",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .default_title_voice_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "default_title_voice_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .default_paragraph_voice_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "default_paragraph_voice_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .default_model_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "default_model_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .quality_preset(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "quality_preset",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .title(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "title",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .author(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "author",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .isbn_number(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "isbn_number",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .acx_volume_normalization(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "acx_volume_normalization",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .volume_normalization(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "volume_normalization",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .pronunciation_dictionary_locators(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "pronunciation_dictionary_locators",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .callback_url(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "callback_url",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_project_v1_projects_add_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddProjectResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_project_v1_projects_add_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Project By Id
    ///
    /// Returns information about a specific project. This endpoint returns more detailed information about a project than GET api.elevenlabs.io/v1/projects.
    ///
    /// - Remark: HTTP `GET /v1/projects/{project_id}`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/get(Get_project_by_ID_v1_projects__project_id__get)`.
    public func Get_project_by_ID_v1_projects__project_id__get(_ input: Operations.Get_project_by_ID_v1_projects__project_id__get.Input) async throws -> Operations.Get_project_by_ID_v1_projects__project_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_project_by_ID_v1_projects__project_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_project_by_ID_v1_projects__project_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProjectExtendedResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_project_by_ID_v1_projects__project_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Project
    ///
    /// Delete a project by its project_id.
    ///
    /// - Remark: HTTP `DELETE /v1/projects/{project_id}`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/delete(Delete_project_v1_projects__project_id__delete)`.
    public func Delete_project_v1_projects__project_id__delete(_ input: Operations.Delete_project_v1_projects__project_id__delete.Input) async throws -> Operations.Delete_project_v1_projects__project_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_project_v1_projects__project_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_project_v1_projects__project_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_project_v1_projects__project_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Convert Project
    ///
    /// Starts conversion of a project and all of its chapters.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}/convert`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/convert/post(Convert_project_v1_projects__project_id__convert_post)`.
    public func Convert_project_v1_projects__project_id__convert_post(_ input: Operations.Convert_project_v1_projects__project_id__convert_post.Input) async throws -> Operations.Convert_project_v1_projects__project_id__convert_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Convert_project_v1_projects__project_id__convert_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/convert",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Convert_project_v1_projects__project_id__convert_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Convert_project_v1_projects__project_id__convert_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Project Snapshots
    ///
    /// Gets the snapshots of a project.
    ///
    /// - Remark: HTTP `GET /v1/projects/{project_id}/snapshots`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/snapshots/get(Get_project_snapshots_v1_projects__project_id__snapshots_get)`.
    public func Get_project_snapshots_v1_projects__project_id__snapshots_get(_ input: Operations.Get_project_snapshots_v1_projects__project_id__snapshots_get.Input) async throws -> Operations.Get_project_snapshots_v1_projects__project_id__snapshots_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_project_snapshots_v1_projects__project_id__snapshots_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/snapshots",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_project_snapshots_v1_projects__project_id__snapshots_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProjectSnapshotsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_project_snapshots_v1_projects__project_id__snapshots_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream Project Audio
    ///
    /// Stream the audio from a project snapshot.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}/snapshots/{project_snapshot_id}/stream`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/snapshots/{project_snapshot_id}/stream/post(Stream_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__stream_post)`.
    public func Stream_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__stream_post(_ input: Operations.Stream_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__stream_post.Input) async throws -> Operations.Stream_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__stream_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Stream_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__stream_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/snapshots/{}/stream",
                    parameters: [
                        input.path.project_id,
                        input.path.project_snapshot_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Stream_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__stream_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Chapters
    ///
    /// Returns a list of your chapters for a project together and its metadata.
    ///
    /// - Remark: HTTP `GET /v1/projects/{project_id}/chapters`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/get(Get_chapters_v1_projects__project_id__chapters_get)`.
    public func Get_chapters_v1_projects__project_id__chapters_get(_ input: Operations.Get_chapters_v1_projects__project_id__chapters_get.Input) async throws -> Operations.Get_chapters_v1_projects__project_id__chapters_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_chapters_v1_projects__project_id__chapters_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_chapters_v1_projects__project_id__chapters_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetChaptersResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_chapters_v1_projects__project_id__chapters_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Chapter By Id
    ///
    /// Returns information about a specific chapter.
    ///
    /// - Remark: HTTP `GET /v1/projects/{project_id}/chapters/{chapter_id}`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/{chapter_id}/get(Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get)`.
    public func Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get(_ input: Operations.Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get.Input) async throws -> Operations.Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters/{}",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ChapterResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Chapter
    ///
    /// Delete a chapter by its chapter_id.
    ///
    /// - Remark: HTTP `DELETE /v1/projects/{project_id}/chapters/{chapter_id}`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/{chapter_id}/delete(Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete)`.
    public func Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete(_ input: Operations.Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete.Input) async throws -> Operations.Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters/{}",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Convert Chapter
    ///
    /// Starts conversion of a specific chapter.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}/chapters/{chapter_id}/convert`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/{chapter_id}/convert/post(Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post)`.
    public func Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post(_ input: Operations.Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post.Input) async throws -> Operations.Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters/{}/convert",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Chapter Snapshots
    ///
    /// Gets information about all the snapshots of a chapter, each snapshot corresponds can be downloaded as audio. Whenever a chapter is converted a snapshot will be automatically created.
    ///
    /// - Remark: HTTP `GET /v1/projects/{project_id}/chapters/{chapter_id}/snapshots`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/{chapter_id}/snapshots/get(Get_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get)`.
    public func Get_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get(_ input: Operations.Get_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get.Input) async throws -> Operations.Get_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters/{}/snapshots",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ChapterSnapshotsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream Chapter Audio
    ///
    /// Stream the audio from a chapter snapshot. Use GET /v1/projects/{project_id}/chapters/{chapter_id}/snapshots to return the chapter snapshots of a chapter.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}/stream`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}/stream/post(Stream_chapter_audio_v1_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post)`.
    public func Stream_chapter_audio_v1_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post(_ input: Operations.Stream_chapter_audio_v1_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post.Input) async throws -> Operations.Stream_chapter_audio_v1_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Stream_chapter_audio_v1_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters/{}/snapshots/{}/stream",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id,
                        input.path.chapter_snapshot_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Stream_chapter_audio_v1_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Pronunciation Dictionaries
    ///
    /// Updates the set of pronunciation dictionaries acting on a project. This will automatically mark text within this project as requiring reconverting where the new dictionary would apply or the old one no longer does.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}/update-pronunciation-dictionaries`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/update-pronunciation-dictionaries/post(Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post)`.
    public func Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post(_ input: Operations.Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post.Input) async throws -> Operations.Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/update-pronunciation-dictionaries",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Dub A Video Or An Audio File
    ///
    /// Dubs provided audio or video file into given language.
    ///
    /// - Remark: HTTP `POST /v1/dubbing`.
    /// - Remark: Generated from `#/paths//v1/dubbing/post(Dub_a_video_or_an_audio_file_v1_dubbing_post)`.
    public func Dub_a_video_or_an_audio_file_v1_dubbing_post(_ input: Operations.Dub_a_video_or_an_audio_file_v1_dubbing_post.Input) async throws -> Operations.Dub_a_video_or_an_audio_file_v1_dubbing_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Dub_a_video_or_an_audio_file_v1_dubbing_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/dubbing",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "target_lang"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "background_audio_file",
                            "csv_file",
                            "dubbing_studio",
                            "end_time",
                            "file",
                            "foreground_audio_file",
                            "highest_resolution",
                            "mode",
                            "name",
                            "num_speakers",
                            "source_lang",
                            "source_url",
                            "start_time",
                            "watermark"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .mode(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "mode",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .file(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "file",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .csv_file(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "csv_file",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .foreground_audio_file(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "foreground_audio_file",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .background_audio_file(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "background_audio_file",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .name(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "name",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .source_url(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "source_url",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .source_lang(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "source_lang",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .target_lang(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "target_lang",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .num_speakers(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "num_speakers",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .watermark(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "watermark",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .start_time(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "start_time",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .end_time(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "end_time",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .highest_resolution(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "highest_resolution",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .dubbing_studio(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "dubbing_studio",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Dub_a_video_or_an_audio_file_v1_dubbing_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DoDubbingResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Dub_a_video_or_an_audio_file_v1_dubbing_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Dubbing Project Metadata
    ///
    /// Returns metadata about a dubbing project, including whether it's still in progress or not
    ///
    /// - Remark: HTTP `GET /v1/dubbing/{dubbing_id}`.
    /// - Remark: Generated from `#/paths//v1/dubbing/{dubbing_id}/get(Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get)`.
    public func Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get(_ input: Operations.Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get.Input) async throws -> Operations.Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/dubbing/{}",
                    parameters: [
                        input.path.dubbing_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Dubbing Project
    ///
    /// Deletes a dubbing project.
    ///
    /// - Remark: HTTP `DELETE /v1/dubbing/{dubbing_id}`.
    /// - Remark: Generated from `#/paths//v1/dubbing/{dubbing_id}/delete(Delete_dubbing_project_v1_dubbing__dubbing_id__delete)`.
    public func Delete_dubbing_project_v1_dubbing__dubbing_id__delete(_ input: Operations.Delete_dubbing_project_v1_dubbing__dubbing_id__delete.Input) async throws -> Operations.Delete_dubbing_project_v1_dubbing__dubbing_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_dubbing_project_v1_dubbing__dubbing_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/dubbing/{}",
                    parameters: [
                        input.path.dubbing_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_dubbing_project_v1_dubbing__dubbing_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_dubbing_project_v1_dubbing__dubbing_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Dubbed File
    ///
    /// Returns dubbed file.
    ///
    /// - Remark: HTTP `GET /v1/dubbing/{dubbing_id}/audio/{language_code}`.
    /// - Remark: Generated from `#/paths//v1/dubbing/{dubbing_id}/audio/{language_code}/get(Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get)`.
    public func Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get(_ input: Operations.Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get.Input) async throws -> Operations.Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/dubbing/{}/audio/{}",
                    parameters: [
                        input.path.dubbing_id,
                        input.path.language_code
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Models
    ///
    /// Gets a list of available models.
    ///
    /// - Remark: HTTP `GET /v1/models`.
    /// - Remark: Generated from `#/paths//v1/models/get(Get_Models_v1_models_get)`.
    public func Get_Models_v1_models_get(_ input: Operations.Get_Models_v1_models_get.Input) async throws -> Operations.Get_Models_v1_models_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_Models_v1_models_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/models",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Models_v1_models_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.ModelResponseModel].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Models_v1_models_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates Audionative Enabled Project.
    ///
    /// Creates AudioNative enabled project, optionally starts conversion and returns project id and embeddable html snippet.
    ///
    /// - Remark: HTTP `POST /v1/audio-native`.
    /// - Remark: Generated from `#/paths//v1/audio-native/post(Creates_AudioNative_enabled_project__v1_audio_native_post)`.
    public func Creates_AudioNative_enabled_project__v1_audio_native_post(_ input: Operations.Creates_AudioNative_enabled_project__v1_audio_native_post.Input) async throws -> Operations.Creates_AudioNative_enabled_project__v1_audio_native_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Creates_AudioNative_enabled_project__v1_audio_native_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/audio-native",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "file",
                            "name"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "author",
                            "auto_convert",
                            "background_color",
                            "image",
                            "model_id",
                            "sessionization",
                            "small",
                            "text_color",
                            "title",
                            "voice_id"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .name(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "name",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .image(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "image",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .author(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "author",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .title(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "title",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .small(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "small",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .text_color(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "text_color",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .background_color(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "background_color",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .sessionization(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "sessionization",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .voice_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "voice_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .model_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "model_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .file(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "file",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .auto_convert(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "auto_convert",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Creates_AudioNative_enabled_project__v1_audio_native_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AudioNativeCreateProjectResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Creates_AudioNative_enabled_project__v1_audio_native_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Voices
    ///
    /// Gets a list of shared voices.
    ///
    /// - Remark: HTTP `GET /v1/shared-voices`.
    /// - Remark: Generated from `#/paths//v1/shared-voices/get(Get_voices_v1_shared_voices_get)`.
    public func Get_voices_v1_shared_voices_get(_ input: Operations.Get_voices_v1_shared_voices_get.Input) async throws -> Operations.Get_voices_v1_shared_voices_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_voices_v1_shared_voices_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/shared-voices",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_size",
                    value: input.query.page_size
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "category",
                    value: input.query.category
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "gender",
                    value: input.query.gender
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "age",
                    value: input.query.age
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "accent",
                    value: input.query.accent
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "search",
                    value: input.query.search
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "use_cases",
                    value: input.query.use_cases
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "descriptives",
                    value: input.query.descriptives
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "featured",
                    value: input.query.featured
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voices_v1_shared_voices_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetLibraryVoicesResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voices_v1_shared_voices_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add A Pronunciation Dictionary
    ///
    /// Creates a new pronunciation dictionary from a lexicon .PLS file
    ///
    /// - Remark: HTTP `POST /v1/pronunciation-dictionaries/add-from-file`.
    /// - Remark: Generated from `#/paths//v1/pronunciation-dictionaries/add-from-file/post(Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post)`.
    public func Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post(_ input: Operations.Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post.Input) async throws -> Operations.Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/pronunciation-dictionaries/add-from-file",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "name"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "description",
                            "file"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .file(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "file",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .name(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "name",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .description(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "description",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddPronunciationDictionaryResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Metadata For A Pronunciation Dictionary
    ///
    /// Get metadata for a pronunciation dictionary
    ///
    /// - Remark: HTTP `GET /v1/pronunciation-dictionaries/{pronunciation_dictionary_id}/`.
    /// - Remark: Generated from `#/paths//v1/pronunciation-dictionaries/{pronunciation_dictionary_id}//get(Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get)`.
    public func Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get(_ input: Operations.Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get.Input) async throws -> Operations.Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/pronunciation-dictionaries/{}/",
                    parameters: [
                        input.path.pronunciation_dictionary_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetPronunciationDictionaryMetadataResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Redirect To Mintlify
    ///
    /// - Remark: HTTP `GET /docs`.
    /// - Remark: Generated from `#/paths//docs/get(redirect_to_mintlify_docs_get)`.
    public func redirect_to_mintlify_docs_get(_ input: Operations.redirect_to_mintlify_docs_get.Input) async throws -> Operations.redirect_to_mintlify_docs_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.redirect_to_mintlify_docs_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/docs",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.redirect_to_mintlify_docs_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
